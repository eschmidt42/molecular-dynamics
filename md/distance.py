# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_distance.ipynb (unless otherwise specified).

__all__ = ['PairwiseDistance', 'pairwise_dist_gram', 'stackoverflow_pairwise_distance', 'torch_pairwise_distance',
           'measure_execution_time', 'get_time_stats', 'DistanceMatrixIndexMapper']

# Cell
import numpy as np
import torch
import plotly.graph_objects as go
import plotly.express as px
import timeit
import typing
import itertools
import pandas as pd
import math

# Cell
class PairwiseDistance:
    def __call__(self, x:torch.Tensor, method:str='torch'):
        return getattr(self, f'{method}_pairwise_distance')(x)

# Cell
def pairwise_dist_gram(x:torch.Tensor, y:torch.Tensor,
                       flat:bool=True) -> torch.Tensor:

    nx = x.size()[0]
    ny = y.size()[0]

    x2 = torch.mm(x, x.t())
    y2 = torch.mm(y, y.t())
    xy = torch.mm(x, y.t())

    x2 = x2.diag().unsqueeze(0).expand(ny,-1)
    y2 = y2.diag().unsqueeze(0).expand(nx,-1)
    d = x2.t() + y2 - 2*xy
    if flat:
        ix = torch.triu_indices(nx,ny,offset=1) #list(zip(*list(itertools.combinations(range(len(positions)), r=2))))
        return d[ix[0],ix[1]]
    return d

# Cell
def stackoverflow_pairwise_distance(self, x:torch.Tensor):
    return pairwise_dist_gram(x, x)

PairwiseDistance.stackoverflow_pairwise_distance = stackoverflow_pairwise_distance

# Cell
def torch_pairwise_distance(self, x:torch.Tensor):
    nx = ny = x.size()[0]
    pdist = torch.nn.PairwiseDistance(p=2, keepdim=True)
    ix = torch.triu_indices(nx,ny,offset=1)
    return pdist(x[ix[0],:], x[ix[1],:]).squeeze(1) ** 2

PairwiseDistance.torch_pairwise_distance = torch_pairwise_distance

# Cell
def measure_execution_time(fun:typing.Callable, args, kwargs,
                           repetitions:int=3, number:int=21):
    return (timeit.Timer(lambda: fun(*args, **kwargs))
            .repeat(repeat=repetitions, number=number))


def get_time_stats(fun:typing.Callable, n:int, d:int,
                   methods:typing.List[str]=['torch', 'stackoverflow'],
                   reps:int=7, number:int=21):

    timing_stats = []
    for method, _n, _d in itertools.product(methods, n, d):
        positions = torch.randn(_n, _d)
        timing_stats.append({
            'n':_n,
            'd':_d,
            'method': method,
            'ts': measure_execution_time(fun, args=(positions,),
                                         kwargs=dict(method=method),
                                         repetitions=reps,
                                         number=number)
        })
    return pd.DataFrame(timing_stats)

# Cell
class DistanceMatrixIndexMapper:

    ix_fun = lambda self, i, j, n: int(n*i -.5*i*(i+1) + j)
    i_fun = lambda self, x, n: int(math.floor((2*n+1 - math.sqrt((2*n+1)**2 - 8*x))*.5))
    j_fun = lambda self, x, i, n: int(x - (n*i -.5*i*(i+1)))

    def __init__(self,num_pos:int):
        self.num_pos = num_pos

    def __call__(self,i:int, direction:str, j:int=None):
        return getattr(self, direction)(i,j)

    def brute_force_square2flat(self, i:int, j:int):
        if i > j: i, j = j, i
        self._check_ix_map()
        return self.ix_map[i,j]

    def _check_ix_map(self):
        if not hasattr(self, 'ix_map'):
            self.ix_map = {ix: i for i, ix in enumerate(itertools.combinations_with_replacement(range(self.num_pos), r=2))}

    def brute_force_flat2square(self, ix:int, j:int=None):
        self._check_ix_map_inv()
        return self.ix_map_inv[ix]

    def _check_ix_map_inv(self):
        self._check_ix_map()
        if not hasattr(self, 'ix_map_inv'):
            self.ix_map_inv = {i: ix for ix, i in self.ix_map.items()}

    def analytical_square2flat(self, i:int, j:int):
        if i > j: i, j = j, i
        return self.ix_fun(i, j, self.num_pos)

    def analytical_flat2square(self, ix:int, j:int=None):
        return (i := self.i_fun(ix, self.num_pos)), (self.j_fun(ix, i, self.num_pos))
