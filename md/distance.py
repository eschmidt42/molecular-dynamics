# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_distance.ipynb (unless otherwise specified).

__all__ = ['PairwiseDistance', 'pairwise_dist_gram', 'stackoverflow_pairwise_distance', 'torch_pairwise_distance',
           'measure_execution_time', 'get_time_stats', 'DistanceMatrixIndexMapper', 'Hull', 'to_2dpositions',
           'plot_atoms_and_hull']

# Cell
import numpy as np
import torch
import plotly.graph_objects as go
import plotly.express as px
import timeit
import typing
import itertools
import pandas as pd
import math

# Cell
class PairwiseDistance:
    def __call__(self, x:torch.Tensor, method:str='torch'):
        return getattr(self, f'{method}_pairwise_distance')(x)

# Cell
def pairwise_dist_gram(x:torch.Tensor, y:torch.Tensor,
                       flat:bool=True) -> torch.Tensor:

    nx = x.size()[0]
    ny = y.size()[0]

    x2 = torch.mm(x, x.t())
    y2 = torch.mm(y, y.t())
    xy = torch.mm(x, y.t())

    x2 = x2.diag().unsqueeze(0).expand(ny,-1)
    y2 = y2.diag().unsqueeze(0).expand(nx,-1)
    d = x2.t() + y2 - 2*xy
    if flat:
        ix = torch.triu_indices(nx,ny,offset=1) #list(zip(*list(itertools.combinations(range(len(positions)), r=2))))
        return d[ix[0],ix[1]]
    return d

# Cell
def stackoverflow_pairwise_distance(self, x:torch.Tensor):
    return pairwise_dist_gram(x, x)

PairwiseDistance.stackoverflow_pairwise_distance = stackoverflow_pairwise_distance

# Cell
def torch_pairwise_distance(self, x:torch.Tensor):
    nx = ny = x.size()[0]
    pdist = torch.nn.PairwiseDistance(p=2, keepdim=True)
    ix = torch.triu_indices(nx,ny,offset=1)
    return pdist(x[ix[0],:], x[ix[1],:]).squeeze(1) ** 2

PairwiseDistance.torch_pairwise_distance = torch_pairwise_distance

# Cell
def measure_execution_time(fun:typing.Callable, args, kwargs,
                           repetitions:int=3, number:int=21):
    return (timeit.Timer(lambda: fun(*args, **kwargs))
            .repeat(repeat=repetitions, number=number))


def get_time_stats(fun:typing.Callable, n:int, d:int,
                   methods:typing.List[str]=['torch', 'stackoverflow'],
                   reps:int=7, number:int=21):

    timing_stats = []
    for method, _n, _d in itertools.product(methods, n, d):
        positions = torch.randn(_n, _d)
        timing_stats.append({
            'n':_n,
            'd':_d,
            'method': method,
            'ts': measure_execution_time(fun, args=(positions,),
                                         kwargs=dict(method=method),
                                         repetitions=reps,
                                         number=number)
        })
    return pd.DataFrame(timing_stats)

# Cell
class DistanceMatrixIndexMapper:

    ix_fun = lambda self, i, j, n: int(n*i -.5*i*(i+1) + j)
    i_fun = lambda self, x, n: int(math.floor((2*n+1 - math.sqrt((2*n+1)**2 - 8*x))*.5))
    j_fun = lambda self, x, i, n: int(x - (n*i -.5*i*(i+1)))

    def __init__(self,num_pos:int):
        self.num_pos = num_pos

    def __call__(self,i:int, direction:str, j:int=None):
        return getattr(self, direction)(i,j)

    def brute_force_square2flat(self, i:int, j:int):
        if i > j: i, j = j, i
        self._check_ix_map()
        return self.ix_map[i,j]

    def _check_ix_map(self):
        if not hasattr(self, 'ix_map'):
            self.ix_map = {ix: i for i, ix in enumerate(itertools.combinations_with_replacement(range(self.num_pos), r=2))}

    def brute_force_flat2square(self, ix:int, j:int=None):
        self._check_ix_map_inv()
        return self.ix_map_inv[ix]

    def _check_ix_map_inv(self):
        self._check_ix_map()
        if not hasattr(self, 'ix_map_inv'):
            self.ix_map_inv = {i: ix for ix, i in self.ix_map.items()}

    def analytical_square2flat(self, i:int, j:int):
        if i > j: i, j = j, i
        return self.ix_fun(i, j, self.num_pos)

    def analytical_flat2square(self, ix:int, j:int=None):
        return (i := self.i_fun(ix, self.num_pos)), (self.j_fun(ix, i, self.num_pos))


# Cell
class Hull:
    unit_vectors:torch.Tensor = None
    magnitudes:torch.Tensor = None
    vecs:torch.Tensor = None

    @classmethod
    def cuboid(self, magnitudes:torch.Tensor):
        d = magnitudes.size()[0]
        box = self()
        box.unit_vectors = torch.diag(torch.ones(d))
        box.magnitudes = magnitudes
        box.vecs = box.unit_vectors * magnitudes
        return box

    def to_2dpositions(self): pass

# Cell
def to_2dpositions(self, d0:int, d1:int):
    to_np = lambda x: x.clone().numpy()
    x = to_np(self.vecs[d0])
    y = to_np(self.vecs[d1])
    xy = to_np(self.vecs[:,d0] + self.vecs[:,d1])

    # adding the origin and the combination of the base vectors
    # the order may look weird but is to finish a whole circle
    x = np.array([0, x[d0], xy[d0], x[d1], 0])
    y = np.array([0, y[d0], xy[d1], y[d1], 0])
    return {'x': x, 'y': y}

Hull.to_2dpositions = to_2dpositions

# Cell
def plot_atoms_and_hull(positions:torch.Tensor,
                        hull:Hull, i:int=0, j:int=1,
                        d0:int=0, d1:int=1):

    d0, d1 = sorted([d0, d1])
    box_pos = hull.to_2dpositions(d0,d1)

    fig = go.Figure(data=[
        go.Scatter(x=box_pos['x'], y=box_pos['y'], name='box',
                   fill='toself', mode='lines', opacity=.5),
        go.Scatter(x=[positions[i,d0]], y=[positions[i,d1]], name='atom i',
                   mode='markers'),
        go.Scatter(x=[positions[j,d0]], y=[positions[j,d1]], name='atom j',
                   mode='markers'),
    ], layout=go.Layout(xaxis_title_text=f'd{d0}', yaxis_title_text=f'd{d1}',
                        title='Atoms in a box'))

    return fig